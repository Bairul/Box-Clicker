<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Box Clicker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.11/addons/p5.dom.min.js"></script>
    <script>
        const HEIGHT = 500;
        const WIDTH = 600;
        const MIN_PADDING = 8;
        const DEFAULT_TIME = 30;
        const GRID_SIZE = 5;
        const BOX_SIZE = HEIGHT / GRID_SIZE;

        const SCOREBOARD_WIDTH = 100;
        const SCOREBOARD_X = WIDTH - SCOREBOARD_WIDTH / 2;
        const SCOREBOARD_TEXTSIZE = 20;
        const HEALTHBAR_Y = 240;
        const HEALTHBAR_SEG_LEN = 100;
        const HEALTHBAR_SEG_WID = HEALTHBAR_SEG_LEN / 2;
        const HEALTH_GAIN = HEALTHBAR_SEG_LEN / 3;
        const MIN_DECAYBAR = HEALTHBAR_Y - 5;
        const MIXED_INTERVAL = 90;

        const BUTTON_HEIGHT = 30;
        const CURSOR_COLOR = 'red';
        
        let canvasPaddingX = 0;
        let canvasPaddingY = 0;
        let startGame = false;
        let firstGame = true;
        let i;

        // gameplay variables
        let time = DEFAULT_TIME;
        let score = 0;
        let highScore = 0;
        let combo = 0;
        let maxCombo = 0;
        let decayBar = 0;
        let point = 0; // point earned per successful hit
        let mixedRandMode = 1;
        // objects
        let currentBox;
        let preBoxes = [];

        // buttons
        let startButton;
        let restartButton;
        let menuButton;
        let backButton;
        let gamemodes;
        let isInMenu = false;
        
        function setup() {
            canvasPaddingX = max(MIN_PADDING, (window.innerWidth - WIDTH) / 2);
            canvasPaddingY = max(MIN_PADDING, (window.innerHeight - HEIGHT) / 2);
            canvas = createCanvas(WIDTH, HEIGHT);
            canvas.position(canvasPaddingX, canvasPaddingY);
            rectMode(CENTER);
            textAlign(CENTER);

            // buttons
            startButton = createButton("Start");
            restartButton = createButton("Restart");
            menuButton = createButton("Menu");
            backButton = createButton("Back");
            gamemodes = createRadio();

            // set button size and position
            startButton.size(80, BUTTON_HEIGHT);
            restartButton.size(90, BUTTON_HEIGHT);
            menuButton.size(60, BUTTON_HEIGHT);
            backButton.size(60, BUTTON_HEIGHT);

            restartButton.position(-WIDTH, -HEIGHT);
            menuButton.position(canvasPaddingX, canvasPaddingY);
            backButton.position(-WIDTH, -HEIGHT);

            // button functions
            restartButton.mouseClicked(initGame);
            startButton.mouseClicked(initGame);
            menuButton.mouseClicked(menuChoose);
            backButton.mouseClicked(backGame);

            // gamemodes
            gamemodes.option('  Classic ', 1);
            gamemodes.option('  Streamy ', 2);
            gamemodes.option('  Jumpy ', 3);
            gamemodes.option('  Mixed ', 4);
            gamemodes.selected(1);
            gamemodes.position(-WIDTH, -HEIGHT);

            // objects
            currentBox = new BOX(genRandGridVal(), genRandGridVal(), 'black');
            preBoxes.push(new PRE_BOX(genRandGridVal(), genRandGridVal(), 'red'));
            // preBoxes.push(new PRE_BOX(genRandGridVal(), genRandGridVal(), 'blue'));
        }

        function drawHealthBar(basedecayBar) {
            rectMode(CORNER);
            let gaugeX = WIDTH - SCOREBOARD_WIDTH + (SCOREBOARD_WIDTH - HEALTHBAR_SEG_WID) / 2;
            // draw healthbar gauge
            fill(180);
            for (i = 0; i <= 2; i++) {
                rect(gaugeX, HEIGHT / 2 - HEALTHBAR_SEG_LEN, HEALTHBAR_SEG_WID, HEALTHBAR_Y - i * 
                                                                                (HEALTHBAR_Y / 3));
            }

            // point decreases as health drops to encourage maintaining health
            if (decayBar <= HEALTHBAR_Y / 3) {
                fill(50, 100, 255, 120); // blue
                point = 100;
            } else if (decayBar > HEALTHBAR_Y / 3 && decayBar < HEALTHBAR_Y / 3 * 2) {
                fill(100, 255, 50, 120); // green
                point = 50;
            } else {
                fill(255, 0, 0, 120); // red
                point = 10;
            }
            // natural decayBar of health gets faster over time
            if (decayBar >= MIN_DECAYBAR) {
                decayBar = MIN_DECAYBAR;
            } else {
                if (time < DEFAULT_TIME / 3) {
                    decayBar += basedecayBar + 1;
                } else if (time >= DEFAULT_TIME / 3 && time < DEFAULT_TIME / 3 * 2) {
                    decayBar += basedecayBar + 0.5;
                } else {
                    decayBar += basedecayBar;
                }
            }
            // decay bar
            rect(gaugeX, HEIGHT / 2 - HEALTHBAR_SEG_LEN + decayBar, HEALTHBAR_SEG_WID, HEALTHBAR_Y - decayBar);

            rectMode(CENTER);
        }

        function drawBoxes() {
            currentBox.display();
            for (i = preBoxes.length - 1; i >= 0; i--) {
                preBoxes[i].display();
            }
        }

        function drawPreBoxLines() {
            stroke(preBoxes[0].c);
            line(currentBox.x, currentBox.y, preBoxes[0].x, preBoxes[0].y);
            for (i = 1; i < preBoxes.length; i++) {
                stroke(preBoxes[i].c);
                line(preBoxes[i - 1].x, preBoxes[i - 1].y, preBoxes[i].x, preBoxes[i].y);
            }
        }

        function drawScoreBoard() {
            if (score > highScore) {
                highScore = score;
            }
            if (combo > maxCombo) {
                maxCombo = combo;
            }

            // scoreboard gui 
            stroke(100, 100, 100);
            fill('white');
            rect(SCOREBOARD_X, HEIGHT / 2, 100, HEIGHT);
            textSize(SCOREBOARD_TEXTSIZE);
            stroke('black');
            strokeWeight(1);
            fill('black');
            text("Highscore:", SCOREBOARD_X, SCOREBOARD_TEXTSIZE);
            text(highScore, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 2);
            text("Score:", SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 3);
            text(score, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 4);
            text("Time:", SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 5);
            
            text("Combo:", SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE * 2);
            text(maxCombo, SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE * 3);
            text("Max:", SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE * 4);

            drawTimer();
            drawCombo();
        }

        function drawTimer() {
            if (time == 0) {
                startGame = false;
            } else if (frameCount % 60 == 0) {
                time--;
            }

            // for mixed gamemode
            if (gamemodes.value() == 4 && frameCount % MIXED_INTERVAL == 0) {
                mixedRandMode = floor(random(1, 4));
            }
            // changes color of countdown timer to red when less than 5 sec
            if (time > 5) {
                text(time, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 6);
            } else {
                fill('red');
                textSize(SCOREBOARD_TEXTSIZE * 2);
                text(time, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 7);
            }
        }

        function drawCombo() {
            // changes color of combo to red when broken combo
            if (combo == 0 && score > 0) {
                fill('red');
                textSize(SCOREBOARD_TEXTSIZE * 2);
                text(combo, SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE / 3);
            } else {
                fill('black');
                textSize(SCOREBOARD_TEXTSIZE);
                text(combo, SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE);
            }
        }

        function drawGrid() { // background grid
            strokeWeight(3);
            stroke(100, 100, 100);
            for(i = 1; i <= GRID_SIZE; i++) {
                line(HEIGHT * i / GRID_SIZE, 0, HEIGHT * i / GRID_SIZE, HEIGHT);
                line(0, HEIGHT * i / GRID_SIZE, HEIGHT, HEIGHT * i / GRID_SIZE);
            }
        }

        function drawCursor(color) {
            noCursor();
            stroke(color);
            strokeWeight(5);
            line(mouseX, mouseY, pmouseX, pmouseY);
        }

        // objects

        function BOX(initX, initY, color) {
            this.x = initX;
            this.y = initY;
            this.c = color;

            this.display = function() {
                fill(this.c);
                noStroke();
                rect(this.x, this.y, BOX_SIZE, BOX_SIZE);
            }

            this.setPos = function(newX, newY) {
                this.x = newX;
                this.y = newY;
            }
        }

        function PRE_BOX(initX, initY, color) {
            this.x = initX;
            this.y = initY;
            this.c = color;

            this.display = function() {
                noFill();
                stroke(this.c);
                strokeWeight(4);
                rect(this.x, this.y, BOX_SIZE, BOX_SIZE);
            }

            this.setPos = function(newX, newY) {
                this.x = newX;
                this.y = newY;
            }
        }

        // gameloop
        function draw() {
            background(175, 200, 255);
            console.log(window.innerWidth);

            if (startGame) {
                drawGrid();
                drawScoreBoard();
                drawHealthBar(1);
                drawBoxes();
                // drawPreBoxLines();
                drawCursor(CURSOR_COLOR);
            } else {
                cursor();
                if (isInMenu) {
                    return;
                }
                menuButton.position(canvasPaddingX, canvasPaddingY);

                if (firstGame) {
                    startButton.position(canvasPaddingX + WIDTH / 2 - 40, canvasPaddingY + HEIGHT / 2 - BUTTON_HEIGHT / 2);
                } else {
                    drawScoreBoard();
                    drawHealthBar(-1);
                    restartButton.position(canvasPaddingX + WIDTH / 2 - 90, canvasPaddingY + HEIGHT / 2 - BUTTON_HEIGHT / 2);
                }
            }
        }

        // when start or restart button is clicked
        function initGame() {
            startGame = true;
            firstGame = false;
            time = DEFAULT_TIME;
            decayBar = 0;
            combo = 0;
            score = 0;

            // get buttons out of sight
            startButton.position(-WIDTH, -HEIGHT);
            restartButton.position(-WIDTH, -HEIGHT);
            menuButton.position(-WIDTH, -HEIGHT);

            // initial box positions
            randAllBoxes();
        }

        function gameplay() {
            if (isOnMouse(currentBox.x, currentBox.y)) {
                // sets current to the first pre-box
                currentBox.setPos(preBoxes[0].x, preBoxes[0].y);
                // sets the previous pre-box to the next one
                for (i = 1; i < preBoxes.length; i++) {
                    preBoxes[i - 1].setPos(preBoxes[i].x, preBoxes[i].y);
                }

                // sets last pre-box to another location depending on gamemode
                if (gamemodes.value() == 1 || (gamemodes.value() == 4 && mixedRandMode == 1)) {
                    preBoxes[preBoxes.length - 1].setPos(genRandGridVal(), genRandGridVal());
                } else if (gamemodes.value() == 2 || (gamemodes.value() == 4 && mixedRandMode == 2)) {
                    streamy();
                } else if (gamemodes.value() == 3 || (gamemodes.value() == 4 && mixedRandMode == 3)) {
                    jumpy();
                }

                // combo and points
                combo++;
                score += point * combo; // point system
                if (decayBar > HEALTH_GAIN) {
                    decayBar -= HEALTH_GAIN;
                } else { // avoid overfill
                    decayBar -= decayBar;
                }
            } else {
                // broken combo
                combo = 0;
                decayBar += 20;
            }
        }

        function streamy() {
            let randX = floor(random(0, 3)) - 1;
            let randY = floor(random(0, 3)) - 1;
            let newX = preBoxes[preBoxes.length - 1].x + randX * BOX_SIZE;
            let newY = preBoxes[preBoxes.length - 1].y + randY * BOX_SIZE;
            while (newX > WIDTH - SCOREBOARD_WIDTH || newX < 0) {
                randX = floor(random(0, 3)) - 1;
                newX = preBoxes[preBoxes.length - 1].x + randX * BOX_SIZE;
            }
            while (newY > HEIGHT || newY < 0) {
                randY = floor(random(0, 3)) - 1;
                newY = preBoxes[preBoxes.length - 1].y + randY * BOX_SIZE;
            }
            preBoxes[preBoxes.length - 1].setPos(newX, newY);
        }

        function jumpy() {
            let newX = genRandGridVal();
            let newY = genRandGridVal();

            while (abs(preBoxes[preBoxes.length - 1].x - newX) < BOX_SIZE) {
                newX = genRandGridVal();
            }
            while (abs(preBoxes[preBoxes.length - 1].y - newY) < BOX_SIZE) {
                newY = genRandGridVal();
            }

            preBoxes[preBoxes.length - 1].setPos(newX, newY);
        }

        function isOnMouse(x, y) {
            return mouseX < x + BOX_SIZE / 2 && mouseX > x - BOX_SIZE / 2
                && mouseY < y + BOX_SIZE / 2 && mouseY > y - BOX_SIZE / 2;
        }

        function randAllBoxes() {
            currentBox.setPos(genRandGridVal(), genRandGridVal());
            for (i = 0; i < preBoxes.length; i++) {
                preBoxes[i].setPos(genRandGridVal(), genRandGridVal());
            }
        }

        function genRandGridVal() {
            return (floor(random(0, GRID_SIZE)) + 0.5) * BOX_SIZE;
        }

        function keyPressed() {
            if (!startGame) {
                return;
            }
            gameplay();
        }

        function mousePressed() {
            if (!startGame) {
                return;
            }
            gameplay();
        }

        // buttons
        // when menu button is clicked
        function menuChoose() {
            isInMenu = true;
            startButton.position(-WIDTH, -HEIGHT);
            restartButton.position(-WIDTH, -HEIGHT);
            menuButton.position(-WIDTH, -HEIGHT);
            backButton.position(canvasPaddingX, canvasPaddingY);
            gamemodes.position(canvasPaddingX + 150, canvasPaddingY + 100);
        }
        // when back button is clicked
        function backGame() {
            isInMenu = false;
            backButton.position(-WIDTH, -HEIGHT);
            menuButton.position(canvasPaddingX, canvasPaddingY);
            gamemodes.position(-WIDTH, -HEIGHT);
        }

        window.onresize = function() { // allow dynamic resizing
            canvasPaddingX = max(MIN_PADDING, (window.innerWidth - WIDTH) / 2);
            canvasPaddingY = max(MIN_PADDING, (window.innerHeight - HEIGHT) / 2);
            canvas.position(canvasPaddingX, canvasPaddingY);
        }
    </script>
</head>
<body>

</body>
</html>