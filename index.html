<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>Box Clicker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.11/addons/p5.dom.min.js"></script>
    <script>
        const HEIGHT = 500;
        const WIDTH = 600;
        const DEFAULT_TIME = 10;
        const GRID_SIZE = 5;
        const BOX_SIZE = HEIGHT / GRID_SIZE;

        const SCOREBOARD_WIDTH = 100;
        const SCOREBOARD_X = WIDTH - SCOREBOARD_WIDTH / 2;
        const SCOREBOARD_TEXTSIZE = 20;
        const HEALTHBAR_Y = 240;
        const HEALTHBAR_SEG_LEN = 100;
        const HEALTHBAR_SEG_WID = HEALTHBAR_SEG_LEN / 2;
        const HEALTH_GAIN = HEALTHBAR_SEG_LEN / 3;
        const MIN_DECAYBAR = HEALTHBAR_Y - 5;

        const BUTTON_HEIGHT = 30;
        
        let startGame = false;
        let firstGame = true;
        let i;

        // gameplay variables
        let time = DEFAULT_TIME;
        let score = 0;
        let highScore = 0;
        let combo = 0;
        let maxCombo = 0;
        let decayBar = 0;
        let point = 0; // point earned per successful hit
        // objects
        let currentBox;
        let preBoxes = [];

        // buttons
        let startButton;
        let restartButton;
        
        function setup() {
            createCanvas(WIDTH, HEIGHT);
            rectMode(CENTER);
            textAlign(CENTER);

            // buttons
            startButton = createButton("Start");
            restartButton = createButton("Restart");

            // set button size and position
            startButton.size(80, BUTTON_HEIGHT);
            restartButton.size(90, BUTTON_HEIGHT);

            restartButton.position(-WIDTH, -HEIGHT);

            // button functions
            restartButton.mouseClicked(initGame);
            startButton.mouseClicked(initGame);

            // objects
            currentBox = new BOX(genRandGridVal(), genRandGridVal(), 'black');
            preBoxes.push(new PRE_BOX(genRandGridVal(), genRandGridVal(), 'red'));
        }

        function drawHealthBar(basedecayBar) {
            rectMode(CORNER);
            let gaugeX = WIDTH - SCOREBOARD_WIDTH + (SCOREBOARD_WIDTH - HEALTHBAR_SEG_WID) / 2;
            // draw healthbar gauge
            fill(180);
            for (i = 0; i <= 2; i++) {
                rect(gaugeX, HEIGHT / 2 - HEALTHBAR_SEG_LEN, HEALTHBAR_SEG_WID, HEALTHBAR_Y - i * 
                                                                                (HEALTHBAR_Y / 3));
            }

            // point decreases as health drops to encourage maintaining health
            if (decayBar <= HEALTHBAR_Y / 3) {
                fill(50, 100, 255, 120); // blue
                point = 100;
            } else if (decayBar > HEALTHBAR_Y / 3 && decayBar < HEALTHBAR_Y / 3 * 2) {
                fill(100, 255, 50, 120); // green
                point = 50;
            } else {
                fill(255, 0, 0, 120); // red
                point = 10;
            }
            // natural decayBar of health gets faster over time
            if (decayBar >= MIN_DECAYBAR) {
                decayBar = MIN_DECAYBAR;
            } else {
                if (time < DEFAULT_TIME / 3) {
                    decayBar += basedecayBar + 1;
                } else if (time >= DEFAULT_TIME / 3 && time < DEFAULT_TIME / 3 * 2) {
                    decayBar += basedecayBar + 0.5;
                } else {
                    decayBar += basedecayBar;
                }
            }
            // decay bar
            rect(gaugeX, HEIGHT / 2 - HEALTHBAR_SEG_LEN + decayBar, HEALTHBAR_SEG_WID, HEALTHBAR_Y - decayBar);

            rectMode(CENTER);
        }

        function drawBoxes() {
            currentBox.display();
            for (i = 0; i < preBoxes.length; i++) {
                preBoxes[i].display();
            }
        }

        function drawScoreBoard() {
            if (score > highScore) {
                highScore = score;
            }
            if (combo > maxCombo) {
                maxCombo = combo;
            }

            // scoreboard gui 
            stroke(100, 100, 100);
            fill('white');
            rect(SCOREBOARD_X, HEIGHT / 2, 100, HEIGHT);
            textSize(SCOREBOARD_TEXTSIZE);
            stroke('black');
            strokeWeight(1);
            fill('black');
            text("Highscore:", SCOREBOARD_X, SCOREBOARD_TEXTSIZE);
            text(highScore, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 2);
            text("Score:", SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 3);
            text(score, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 4);
            text("Time:", SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 5);
            
            text("Combo:", SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE * 2);
            text(maxCombo, SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE * 3);
            text("Max:", SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE * 4);

            drawTimer();
            drawCombo();
        }

        function drawTimer() {
            if (time == 0) {
                startGame = false;
            } else if (frameCount % 60 == 0) {
                time--;
            }
            // changes color of countdown timer to red when less than 5 sec
            if (time > 5) {
                text(time, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 6);
            } else {
                fill('red');
                textSize(SCOREBOARD_TEXTSIZE * 2);
                text(time, SCOREBOARD_X, SCOREBOARD_TEXTSIZE * 7);
            }
        }

        function drawCombo() {
            // changes color of combo to red when broken combo
            if (combo == 0 && score > 0) {
                fill('red');
                textSize(SCOREBOARD_TEXTSIZE * 2);
                text(combo, SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE / 3);
            } else {
                fill('black');
                textSize(SCOREBOARD_TEXTSIZE);
                text(combo, SCOREBOARD_X, HEIGHT - SCOREBOARD_TEXTSIZE);
            }
        }

        function drawGrid() { // background grid
            strokeWeight(3);
            stroke(100, 100, 100);
            for(i = 1; i <= GRID_SIZE; i++) {
                line(HEIGHT * i / GRID_SIZE, 0, HEIGHT * i / GRID_SIZE, HEIGHT);
                line(0, HEIGHT * i / GRID_SIZE, HEIGHT, HEIGHT * i / GRID_SIZE);
            }
        }

        function drawCursor(color) {
            noCursor();
            stroke(color);
            strokeWeight(5);
            line(mouseX, mouseY, pmouseX, pmouseY);
        }

        // objects

        function BOX(initX, initY, color) {
            this.x = initX;
            this.y = initY;
            this.c = color;

            this.display = function() {
                fill(this.c);
                noStroke();
                rect(this.x, this.y, BOX_SIZE, BOX_SIZE);
            }

            this.setPos = function(newX, newY) {
                this.x = newX;
                this.y = newY;
            }
        }

        function PRE_BOX(initX, initY, color) {
            this.x = initX;
            this.y = initY;
            this.c = color;

            this.display = function() {
                noFill();
                stroke(this.c);
                strokeWeight(4);
                rect(this.x, this.y, BOX_SIZE, BOX_SIZE);
            }

            this.setPos = function(newX, newY) {
                this.x = newX;
                this.y = newY;
            }
        }

        // gameloop
        function draw() {
            background(175, 200, 255);

            if (startGame) {
                drawGrid();
                drawScoreBoard();
                drawHealthBar(1);
                drawBoxes();
                drawCursor('red');
            } else {
                cursor();
                if (firstGame) {
                    startButton.position(WIDTH / 2 - 40, HEIGHT / 2 - BUTTON_HEIGHT / 2);
                } else {
                    drawScoreBoard();
                    drawHealthBar(-1);
                    restartButton.position(WIDTH / 2 - 90, HEIGHT / 2 - BUTTON_HEIGHT / 2);
                }
            }
        }

        // when start or restart button is clicked
        function initGame() {
            startGame = true;
            firstGame = false;
            time = DEFAULT_TIME;
            decayBar = 0;
            combo = 0;
            maxCombo = 0;
            score = 0;

            // get buttons out of sight
            startButton.position(-width,-height);
            restartButton.position(-width,-height);
            randAllBoxes();
        }

        function keyPressed() {
            if (!startGame) {
                return;
            }
            gameplay();
        }

        function mousePressed() {
            if (!startGame) {
                return;
            }
            gameplay();
        }

        function gameplay() {
            if (isOnMouse(currentBox.x, currentBox.y)) {
                // sets current to the first pre-box
                currentBox.setPos(preBoxes[0].x, preBoxes[0].y);
                // sets the previous pre-box to the next one
                for (i = 1; i < preBoxes.length; i++) {
                    preBoxes[i - 1].setPos(preBoxes[i].x, preBoxes[i].y);
                }
                // sets last pre-box to another location
                preBoxes[preBoxes.length - 1].setPos(genRandGridVal(), genRandGridVal());

                // combo and points
                combo++;
                score += point * combo; // point system
                if (decayBar > HEALTH_GAIN) {
                    decayBar -= HEALTH_GAIN;
                } else { // avoid overfill
                    decayBar -= decayBar;
                }
            } else {
                // broken combo
                combo = 0;
                decayBar += 20;
            }
        }

        function isOnMouse(x, y) {
            return mouseX < x + BOX_SIZE / 2 && mouseX > x - BOX_SIZE / 2
                && mouseY < y + BOX_SIZE / 2 && mouseY > y - BOX_SIZE / 2;
        }

        function randAllBoxes() {
            currentBox.setPos(genRandGridVal(), genRandGridVal());
            for (i = 0; i < preBoxes.length; i++) {
                preBoxes[i].setPos(genRandGridVal(), genRandGridVal());
            }
        }

        function genRandGridVal() {
            return (floor(random(0, GRID_SIZE)) + 0.5) * BOX_SIZE;
        }
    
    </script>
</head>
<body>

</body>
</html>